% Template file for an a0 portrait poster.
% Written by Graeme, 2001-03 based on his SOC poster.
%
% See discussion and documentation at
% <http://www.astro.gla.ac.uk/users/norman/docs/posters/> 
%
% $Id: poster-template-portrait.tex,v 1.2 2002/12/03 11:25:55 norman Exp $



% We switch to portrait mode. This works as advertised.
\documentclass[a0,portrait]{a0poster}
%\documentclass[draft]{a0poster}

% You might find the 'draft' option to a0 poster useful if you have
% lots of graphics, because they can take some time to process and
% display. (\documentclass[a0,draft]{a0poster})

% Switch off page numbers on a poster, obviously, and section numbers too.
\pagestyle{empty}
\setcounter{secnumdepth}{0}

% The textpos package is necessary to position textblocks at arbitary 
% places on the page.
\usepackage[absolute]{textpos}

% Graphics to include graphics. Times is nice on posters, but you
% might want to switch it off and go for CMR fonts.
\usepackage[final]{graphics}
\usepackage{wrapfig,times}
%\usepackage[ansinew]{inputenc}
%\usepackage[brazilian]{babel}

% These colours are tried and tested for titles and headers. Don't
% over use color!
\usepackage{color}
\definecolor{DarkBlue}{rgb}{0.1,0.1,0.5}
\definecolor{Red}{rgb}{0.9,0.0,0.1}
\definecolor{DarkGreen}{rgb}{0.10,0.50,0.10}

% see documentation for a0poster class for the size options here
\let\Textsize\normalsize
\def\Head#1{\noindent\hbox to \hsize{\hfil{\LARGE\color{DarkBlue} #1}}\bigskip}
\def\LHead#1{\noindent{\large\color{DarkBlue} #1}\smallskip}
\def\Subhead#1{\noindent{\large\color{DarkBlue} #1}}
\newcommand{\quiteHuge}{\fontsize{70.3}{93}\selectfont}
\def\Title#1{\begin{center}\noindent{\quiteHuge\color{DarkGreen}#1}\end{center}}

\usepackage[brazil]{babel}
\usepackage[latin1]{inputenc}
\usepackage{abnt-alf}
\usepackage{graphicx}
\usepackage{float}														%Package para figuras



% Set up the grid
%
% Note that [40mm,40mm] is the margin round the edge of the page --
% it is _not_ the grid size. That is always defined as 
% PAGE_WIDTH/HGRID and PAGE_HEIGHT/VGRID. In this case we use
% 15 x 25. This gives us a wide central column for text (7 grid
% spacings) and two narrow columns (3 each) at each side for 
% pictures, separated by 1 grid spacing.
%
% Note however that texblocks can be positioned fractionally as well,
% so really any convenient grid size can be used.
%
\TPGrid[20mm,20mm]{17}{25}  % 3 - 1 - 7 - 1 - 3 Columns

% Mess with these as you like
\parindent=0pt
%\parindent=1cm
\parskip=0.5\baselineskip

% abbreviations
\newcommand{\ddd}{\,\mathrm{d}}

\begin{document}

% Understanding textblocks is the key to being able to do a poster in
% LaTeX. In
%
%    \begin{textblock}{wid}(x,y)
%    ...
%    \end{textblock}
%
% the first argument gives the block width in units of the grid
% cells specified above in \TPGrid; the second gives the (x,y)
% position on the grid, with the y axis pointing down.

% You will have to do a lot of previewing to get everything in the 
% right place.

% This gives good title positioning for a portrait poster.
% Watch out for hyphenation in titles - LaTeX will do it
% but it looks awful.
\begin{textblock}{14}(1.5,0.5)
\Title{{\textsc {\textsc Desenvolvimento de um Microprocessador 8086 na Arquitetura RISC}}}
\end{textblock}

\begin{textblock}{17}(0.3,1.5)
\begin{center}
\parbox{0.2\textwidth}{
    \begin{center}
    \LHead{Dênis Araújo da Silva}  \\
    \LHead{Engenharia da Computação} \\
    \LHead{Universidade Federal de Itajubá} \\
    \LHead{\texttt{silvadenisaraujo@gmail.com}} 
    \end{center}
}
\parbox{0.2\textwidth}{
    \begin{center}
    \LHead{Marcos Aurélio F. de A. Costa} \\
    \LHead{Engenharia da Computação} \\
    \LHead{Universidade Federal de Itajubá} \\
    \LHead{\texttt{macaufreitas@gmail.com}} 
    \end{center}
}
\parbox{0.2\textwidth}{
    \begin{center}
    \LHead{Maurílio Pereira Coutinho} \\
    \LHead{Orientador} \\
    \LHead{Universidade Federal de Itajubá} \\
    \LHead{\texttt{mc9@unifei.edu.br}} 
    \end{center}
}
\parbox{0.2\textwidth}{
    \begin{center}
    \LHead{Robson Luiz Moreno} \\
    \LHead{Co-Orientador} \\
    \LHead{Universidade Federal de Itajubá} \\
    \LHead{\texttt{moreno@unifei.edu.br}} 
    \end{center}
}
\end{center}
\end{textblock}


% Put the GU logo in the top right.
\begin{textblock}{2}(15.5,0)
%Your logo here.
\resizebox{1.5\TPHorizModule}{!}{\includegraphics{figuras/LogoEFEI.jpg}}
\end{textblock}
\begin{textblock}{2}(0,0)
%Your logo here.
\resizebox{1.5\TPHorizModule}{!}{\includegraphics{figuras/Brasao.png}}
\end{textblock}


% Abstract

\begin{textblock}{5}(0.3,3.6)
  \LHead{Abstract}

	The Reduced Instruction Set Computers (RISC) are receiving much attention in the last few years. The main concept of this architecture allows a fast execution in nowadays machines. Once we have fast memories, it isn't necessary to avoid accessing it, so short instructions which do a simple task is the better option. This way, this paper introduce the job of converting a CISC machine (iAPX8086) in a RISC one. The whole process consist in analyse and reduce the instruction set, after this some adjustments need to be done, like adapter all the instructions in order to have all of them in the same size.
  
\vspace{0.3cm}
 \LHead{Introdução}

\par A arquitetura CISC possui um conjunto de instruções extenso, onde cada instrução é capaz de executar uma tarefa bastante complexa. Tal formato requer instruções de tamanhos variados e que necessitam de uma diferente quantidade de ciclos de clock para serem executadas. Esta definição é válida quando se trabalha com memórias de baixa velocidade, onde cada acesso é custoso, e se torna necessário evitar acessos à memória de modo a reduzir o tempo de execução. Porém, atualmente as memórias são de alto desempenho, o que torna desnecessário o intuito de evitar acessá-las.

\par Por sua vez, a arquitetura RISC possui um conjunto de instruções reduzido, onde cada instrução é capaz de realizar um simples tarefa. Há instruções específicas para acessar a memória, de modo a permitir que a seguinte regra possa ser respeitada: A cada ciclo de clock uma nova instrução deve começar a ser executada. Nesta arquitetura todas as instruções possuem o mesmo tamanho e levam a mesma quantidade de cliclos de clock para serem executadas, com excessão das instruções que acessam a memória. Desta forma, este formato é interessante para o hardware disponível atualmente.

\vspace{0.3cm}
 \LHead{Desenvolvimento}

   De acordo com \cite{ComputerOrg}, uma das mais importantes abstrações é a interface entre o hardware e o software de baixo nível. Por causa de sua importância, é dado uma nomenclatura especial: \textbf{arquitetura do conjunto de instruções} (ISA), ou simplesmente arquitetura de uma máquina. O conjunto de instruções, inclui qualquer coisa que programadores necessitam para saber como programar em linguagem de máquina corretamente, incluem instruções, dispositivos E/S, entre outros. Tipicamente o sistema operacional irá encapsular os detalhes da realização da E/S, alocação de memória, e outras funcionalidades de baixo nível do sistema, portanto, programadores não precisam se preocupar com estes detalhes. Dois tipos de conjuntos de instruções existentes serão explicados a diante.
 
	\textbf{CISC} é uma arquitetura de processador, que teve como princípio o uso eficiente de memória e a facilidade de programar. Cada instrução desse processador tem várias operações em seu interior ajudando o programador a implementar programas. A maioria dos projetos de microprocessadores comuns - incluindo o Intel (R) 80x86 e séries Motorola 68K - também seguem a filosofia CISC \cite{CISC}.
 
	Na década de 1980, ocorreu as mudanças para a nova arquitetura, o modelo \textbf{RISC} (Reduced Instruction Set Computer). As melhorias nas linguagens de programação, tecnologia de compiladores e custo de memória significaram que, menos programação estava sendo feita no nível do assembly, de modo que os conjuntos de instruções poderiam ser medidos pela forma como os compiladores os usavam, ao contrário de como os programadores em assembly os usavam.
	Praticamente todos os novos conjuntos de instruções desde 1982, seguiram essa filosofia RISC de
tamanhos de instrução fixos, conjuntos de instrução load/store, modos de endereçamento limitados e
operações limitadas. ARM, Hitachi SH, IBM PowerPC, MIPS e Sun SPARC são todos exemplos de
arquiteturas RISCs \cite{ComputerOrg}.  
	
%	Portanto, a \textbf{regra de ouro} é que  todas as instruções devem ser executadas em apenas um ciclo de máquina e devem possuir um tamanho fixo. O problema quanto à regra de ouro são as instruções LOAD e STORE que requerem mais ciclos de relógio, uma vez que estas fazem acesso à memória. Neste ponto, a regra de ouro tem de ser adaptada. A solução proposta é que a cada ciclo de relógio a execução de uma nova instrução seja iniciada. E nessa característica é que entra o uso da técnica de \textbf{pipelining}.

	\begin{figure}[ht] \centering
		\includegraphics[scale=0.7]{figuras/fluxograma-maquinas.jpg}
		\caption{Fluxograma das máquinas CISC e RISC}
		\label{FigEstruturaInstrucao}
	\end{figure}
	
	Para o microprocessador desenvolvido neste trabalho as instruções possuem 4 bytes. Este tamanho de instrução foi definido visando respeitar a \textbf{regra de ouro}, onde todas as instruções tem o mesmo tamanho. Na figura \ref{FigEstruturaInstrucao} a seguir tem-se a estrutura das instruções aritméticas e lógicas e na figura \ref{FigEstruturaInstrucaoMOV} a seguir tem-se a estrutura da instrução MOV.
	
	\begin{figure}[ht] \centering
		\includegraphics[scale=0.15]{figuras/estrutura_instrucao.jpg}
		\caption{Bytes das Instruções Aritméticas e Lógicas}
		\label{FigEstruturaInstrucao}
		\includegraphics[scale=0.15]{figuras/estrutura_instrucao_mov.jpg}
		\caption{Bytes da Instrução MOV}
		\label{FigEstruturaInstrucaoMOV}
	\end{figure}
\end{textblock}

% ----------------------------------------------------------------------------------------------------------
% Fim da primeira coluna
% ----------------------------------------------------------------------------------------------------------

\begin{textblock}{5}(6,3.6)

"\textit{O design do conjunto de instruções deve ter vários objetivos, sendo o mais óbvio e útil a performance do microprocessador.}"\cite{ArtigoVLSI}.

	Neste momento a preocupação é desenvolver um microprocessador que tenha um funcionamento básico e muito explí­cito, pois o foco deste trabalho não é desenvolver uma tecnologia nova, porém compreender profundamente o desenvolvimento da arquitetura e dos componentes de um microprocessador e lembrando que, as máquinas RISC só se tornaram viáveis devido aos avanços de software no aparecimento de compiladores otimizados.\cite{RISCUnicamp}.

	Para o devido gerenciamento de memória, o microprocessador a ser desenvolvido não irá ter em seu conjunto os modos que fazem uso de \textbf{segmentação}, portanto a memória será enxergada como uma memória linear. Como se tivessemos somente um segmento sendo utilizado, tal definição será explicitada mais a diante. Semelhante ao funcionamento do micrprocessador 386 que possui além de um modo de memória segmentada, um modo protegido o qual a memória é vista linearmente.

	Portanto, após todas as considerações tomadas para o desenvolvimento do conjunto de instruções, temos na tabela \ref{tabelaInstrucoes} o conjunto de instruções escolhido para o desenvolvimento deste microprocessador.
	
		\begin{table}[htbp]
		\centering
  		\caption{Instruções Escolhidas e seus devidos Opcodes}
  		\begin{tabular}{|c|c|}
			\hline
			Instrução & Opcode \\
			\hline
			\textbf{ADD  Reg16,Imed 16} & 10000001 11000 R/M I16L I16H \\
			\hline
			\textbf{OR     Reg16,Imed16} & 10000001 11001 R/M I16L I16H \\
			\hline
		    \textbf{ADC  Reg16,Imed16} & 10000001 11010 R/M I16L I16H \\
		    \hline
		    \textbf{SBB   Reg16,Imed16} & 10000001 11011 R/M I16L I16H \\
		    \hline
		    \textbf{AND  Reg16,Imed16} & 10000001 11100 R/M I16L I16H \\
		    \hline
		    \textbf{SUB   Reg16,Imed16} & 10000001 11101 R/M I16L I16H \\
		    \hline
		    \textbf{XOR   Reg16,Imed16} & 10000001 11110 R/M I16L I16H \\
		    \hline
		    \textbf{CMP  Reg16,Imed16} & 10000001 11111 R/M I16L I16H \\
		    \hline
		    \textbf{MOV Reg16,Imed16} & 00000000 10111 R/M I16L I16H \\
		    \hline
		\end{tabular}
		\label{tabelaInstrucoes}
		\end{table}

\vspace{0.3cm}
 \LHead{Implementação em VHDL}

\par Para realizar a implementação baseou-se nos componentes internos conhecidos do microprocessador Intel 8086 e buscou-se a maneira mais nítida e auto-explicativa, o funcionamento de cada componente desenvolvido, a seguir temos todos os componentes desenvolvidos que compõem o nosso microprocessador.
	\begin{itemize}
		\item \textbf{Registro de Propósito Geral:} O registrador de próposito geral tem como objetivo encapsular os registradores AX, BX, CX, DX, SP, BP, SI e DI, onde cada registro possui seu devido código R/M a ser substituído nas intruções aritméticas e lógicas.

		\item \textbf{Registro de Segmento:} Com funcionamento semelhante do Registro de Propósito Geral, possui o objetivo de encaplusar os registradores que possuem o funcionamento de manipulação de memória que são, CS, ES, DS, SS, além do contador de índice IP. Diferentemente, do Registro de Popósito Geral, o registro de Segmento, possui uma linha de entrada denominada incrementa IP, tal linha foi implementada a fim de facilitar o comando de incremento de IP para se caminhar continuamente na memória, sendo que o registro possui acesso direto ao registrador IP, em vez de se desenvolver uma estrutura própria para este cálculo.
		
		\item \textbf{Calculadora de Endereço:} Foi desenvolvido uma calculadora de endereço para realizar o cálculo do endereço relativo para o endereço físico.
		
		\item \textbf{Demultiplexador e Multiplexador:} Utilizados para realizar a comunicação entre alguns componentes.
		 
		\item \textbf{Registro de Flags:} O Registro de Flags tem como objetivo guardar o resultado dos Flags que são calculado pela Unidade Lógica Aritmética.

		\item \textbf{Unidade Aritmética e Lógica:} É a estrutura responsável por executar todas as operações aritméticas e lógicas do microprocessador. É composta por algumas estruturas auxiliares que implementam funcionalidades necessárias na execução bit a bit de cada instrução.
		
		\begin{itemize}
			\item \textbf{Detector do Flag Auxiliar:} É uma estrutura criada para ser utilizada na Unidade Aritmética e Lógica. Esta estrutura detecta a ocorrência de um "vai um" do bit 3 para o bit 4 ou quando há "vem um" do bit 4 para o bit 3, durante a execução de alguma instrução aritmética.
			\item \textbf{Detector do Flag de Paridade:} É uma estrutura que detecta a paridade do resultado obtido em uma instrução aritmética ou lógica. Caso haja um número par de bits 1 no resultado da operação, o flag de paridade recebe valor 1, caso contrário, recebe valor 0.7
			\item \textbf{Detector do Zero Flag:} Esta estrutura verifica o resultado obtido em uma operação aritmética ou lógica. Caso o valor final seja 0, o zero flag recebe valor 1, caso contrário, recebe valor 0.
		\end{itemize}
		\item \textbf{Unidade de Controle de Endereços:} A Unidade de Controle de Endereços possui como objetivo controlar alguns componentes a maneira de realizar a perfeita sincronização entre eles, e que exista um fluxo consistente de dados entre as estruturas para que o cálculo que seja realizado, e que seja correto.
	\end{itemize}

\end{textblock}

%---------------------------------------------------------------------------------------
% Fim da Segunda Coluna
%---------------------------------------------------------------------------------------

\begin{textblock}{5}(11.7,3.6)

  \begin{itemize}
  	\item \textbf{Unidade de Controle:} A Unidade de Controle é uma das principais estruturas do microprocessador. Ela é responsável por 3 funções básicas: busca (fetch), decodificação e execução. Além disso, gera todos os sinais que controlam as unidades \textit{escravas} à ela. A \textit{Unidade de Controle de Endereços} é uma máquina de estados escrava à unidade de controle, portanto há um sinal de habilitação que conecta essas duas unidades que é enviado pela Unidade de Controle, tornando-a uma máquina de estados \textit{master}.
  \end{itemize}
  
  \begin{figure}[ht] \centering
		\includegraphics[scale=0.5]{figuras/diagrama_estados_unidade_controle.jpg}
		\caption{Diagrama de Estados da Unidade de Controle}
		\label{MEUnicadeControle}
  \end{figure}

  \begin{figure}[ht] \centering
		\includegraphics[scale=1]{figuras/DiagramaEstadosEnd.png}
		\caption{Diagrama de Estados da Unidade de Controle de Endereços}
		\label{RTLMicro}
  \end{figure}

  \begin{figure}[ht] \centering
		\includegraphics[scale=1]{figuras/RTLMicro.png}
		\caption{Visão RTL do Microprocessador Desenvolvido}
		\label{RTLMicro}
  \end{figure}

\vspace{0.3cm}
  \LHead{Conclusão}

\par Conforme descrito neste documento, a adaptação de uma máquina CISC para RISC é um trabalho válido, onde se tem uma redução da quantidade de instruções disponíveis e a diminuição no tempo de execução de cada uma.
	
\par O microprocessador resultante deste trabalho é uma máquina eficaz e de simples programação. Estão disponíveis as principais instruções necessárias, com as quais é possível escrever programas que executam as mais diversas tarefas. O desempenho destes programas é de certa forma incrementado e o resultado obtido é considerado satisfatório.

\par Uma boa comparação a ser feita é a análise do código do sistema operacional DOS da Microsoft. Onde as instruções mais utilizadas são as que constam na máquina desenvolvida neste documento.

\bibliographystyle{abntex2-alf}

\bibliography{biblio}             %% REFERÊNCIAS (deve-se possuir o arquivo do tipo bibtex)

\begin{figure}[ht] \centering
		\includegraphics[scale=1]{figuras/github.png}
\end{figure}

\end{textblock}

\end{document}
