\chapter{Resultados}
O processador implementado foi testado da seguinte maneira, foi criado um arquivo \textit{testbench} e através dos resultados fornecidos pelo software ModelSim - Altera, selecionando somente os sinais internos de interesse da instrução, que será colocada diretamente no barramento de dados, em sua forma hexadecimal. 
Nas próximas seções, serão detalhadas todas as instruções implementadas, uma a uma com o seu devido resultado do \textit{testbench}.

Temos na Figura \ref{FigTestes}, a visão RTL da estrutura de simulação que é a conexão de uma memória ROM que possui o código a ser executado e o microprocessador.
	\begin{figure} \centering
		\includegraphics[scale=0.35]{imagensResultados/estruturaTesteMicroROM.png}
		\caption{Visão RTL da estrutura de testes}
		\label{FigTestes}
	\end{figure}

Temos na Figura \ref{FigMicroFinal}, a visão RTL da estrutura do microprocessador completo, com todas as estruturas e ligações necessárias para o perfeito funcionamento.

\begin{figure} \centering
		\includegraphics[scale=0.65]{imagensResultados/microRISCFinalRTL.png}
		\caption{Visão RTL do microprocessador com todas estruturas corretas e funcionais}
		\label{FigMicroFinal}
	\end{figure}
\begin{figure} \centering
		\includegraphics[scale=0.65]{imagensResultados/focoMux.png}
		\caption{Visão RTL do microprocessador com foco no Multiplexador}
		\label{FigMicroFinal}
	\end{figure}
\begin{figure} \centering
		\includegraphics[scale=0.65]{imagensResultados/focoDemux.png}
		\caption{Visão RTL do microprocessador com foco no Demultiplexador}
		\label{FigMicroFinal}
	\end{figure}
\begin{figure} \centering
		\includegraphics[scale=0.65]{imagensResultados/focoRegDados.png}
		\caption{Visão RTL do microprocessador com foco no Registro de Dados}
		\label{FigMicroFinal}
	\end{figure}
\begin{figure} \centering
		\includegraphics[scale=0.65]{imagensResultados/focoULA.png}
		\caption{Visão RTL do microprocessador com foco na Unidade Lógica Aritmética}
		\label{FigMicroFinal}
	\end{figure}
\begin{figure} \centering
		\includegraphics[scale=0.65]{imagensResultados/focoFlags.png}
		\caption{Visão RTL do microprocessador com foco no Registro de Flags}
		\label{FigMicroFinal}
	\end{figure}
\begin{figure} \centering
		\includegraphics[scale=0.65]{imagensResultados/focoUC.png}
		\caption{Visão RTL do microprocessador com foco na Unidade de Controle}
		\label{FigMicroFinal}
	\end{figure}
\begin{figure} \centering
		\includegraphics[scale=0.65]{imagensResultados/focoUCE.png}
		\caption{Visão RTL do microprocessador com foco na Unidade de Controle de Endereço}
		\label{FigMicroFinal}
	\end{figure}
\begin{figure} \centering
		\includegraphics[scale=0.65]{imagensResultados/focoRegSeg.png}
		\caption{Visão RTL do microprocessador com foco no Registro de Segmento}
		\label{FigMicroFinal}
	\end{figure}
\begin{figure} \centering
		\includegraphics[scale=0.65]{imagensResultados/focoCalc.png}
		\caption{Visão RTL do microprocessador com foco na Calculadora de Endereço}
		\label{FigMicroFinal}
	\end{figure}
	
\section{ADD Reg16,Imed16}
Esta instrução adiciona ao valor do registro um valor imediato de 16 bits, a instrução de teste em hexadecimal é definida como \textbf{81C0 00FF} onde 81C0h é o opcode da instrução e 00FFh é o valor imediato a ser somado no registro AX, por utilizar R/M igual a 000 como vimos anteriormente. Na figura \ref{FigResultAdd} podemos ver o resultado da execução do \textit{testbench}, com os sinais que mais nos interessam no funcionamento tanto da memória quanto do microprocessador para esta operação, as linhas de relógio e reset são responsáveis pelo funcionamento e passo a passo do microprocessador, tanto que enquanto a linha de reset não fica em nível alto, o microprocessador não responde. Temos os sinais dos estados da Unidade de Controle e da Unidade de Controle de Endereço, úteis para verificar se a linha de raciocínio, presente nos grafos descritos anteriormente, está correta e respeitando a ordem de mestre e escravo imposta. Temos o endereço e a saída da memória ROM, exteriorizadas de maneira a verificar se o microprocessador está colocando no barramento de endereço o valor correto e se a memória coloca no barramento de dados o valor correto do \textit{opcode}. Além disso, temos o enumerado descrito na Unidade Lógica e Aritmética para verificarmos qual operação é realizada dentro deste componente, podemos ver que esta linha se mantem em  \textbf{op\_add}, e por fim temos o registrador AX, o qual está sendo manipulado, para verificarmos a alteração em seu valor. Podemos verificar que a instrução está funcionando corretamente, pois o valor do registrador AX é alterado para \textbf{00FFh} após a execução da instrução e todos os estados são percorridos, como realmente deveriam ser em ambas unidades de controle.

\begin{landscape}
	\begin{figure}
		\includegraphics[scale=0.5]{imagensResultados/OperacaoAdd.png}
		\caption{Resultado Teste Operação ADD}
		\label{FigResultAdd}
	\end{figure}
\end{landscape}

\section{OR Reg16,Imed16}
Esta instrução realiza a operação \"OU\"  bit a bit do valor do registro com um valor imediato de 16 bits, a instrução de teste em hexadecimal é definida como \textbf{81C8 1234} onde 81C8h é o opcode da instrução e 1234h é o valor imediato a ser realizado a operação \"OU\"  no registro AX, por utilizar R/M igual a 000 como vimos anteriormente. Na figura \ref{FigResultOr} podemos ver o resultado da execução do \textit{testbench}, com os sinais que mais nos interessam no funcionamento tanto da memória quanto do microprocessador para esta operação, as linhas de relógio e reset são responsáveis pelo funcionamento e passo a passo do microprocessador, tanto que enquanto a linha de reset não fica em nível alto, o microprocessador não responde. Temos os sinais dos estados da Unidade de Controle e da Unidade de Controle de Endereço, úteis para verificar se a linha de raciocínio, presente nos grafos descritos anteriormente, está correta e respeitando a ordem de mestre e escravo imposta. Temos o endereço e a saída da memória ROM, exteriorizadas de maneira a verificar se o microprocessador está colocando no barramento de endereço o valor correto e se a memória coloca no barramento de dados o valor correto do \textit{opcode}. Além disso, temos o enumerado descrito na Unidade Lógica e Aritmética para verificarmos qual operação é realizada dentro deste componente, podemos ver que esta linha é alterada para \textbf{op\_a\_or\_b}, e por fim temos o registrador AX, o qual está sendo manipulado, para verificarmos a alteração em seu valor. Podemos verificar que a instrução está funcionando corretamente, pois o valor do registrador AX é alterado para \textbf{1234h} após a execução da instrução e todos os estados são percorridos, como realmente deveriam ser em ambas unidades de controle.

\begin{landscape}
	\begin{figure}
		\includegraphics[scale=0.5]{imagensResultados/OperacaoOr.png}
		\caption{Resultado Teste Operação OR}
		\label{FigResultOr}
	\end{figure}
\end{landscape}

\section{ADC Reg16,Imed16}
Esta instrução adiciona, com carry, ao valor do registro um valor imediato de 16 bits, a instrução de teste em hexadecimal é definida como \textbf{81D0 1234} onde 81D0h é o opcode da instrução e 1234h é o valor imediato a ser somado com carry no registro AX, por utilizar R/M igual a 000 como vimos anteriormente. Na figura \ref{FigResultAdc} podemos ver o resultado da execução do \textit{testbench}, com os sinais que mais nos interessam no funcionamento tanto da memória quanto do microprocessador para esta operação, as linhas de relógio e reset são responsáveis pelo funcionamento e passo a passo do microprocessador, tanto que enquanto a linha de reset não fica em nível alto, o microprocessador não responde. Temos os sinais dos estados da Unidade de Controle e da Unidade de Controle de Endereço, úteis para verificar se a linha de raciocínio, presente nos grafos descritos anteriormente, está correta e respeitando a ordem de mestre e escravo imposta. Temos o endereço e a saída da memória ROM, exteriorizadas de maneira a verificar se o microprocessador está colocando no barramento de endereço o valor correto e se a memória coloca no barramento de dados o valor correto do \textit{opcode}. Temos também a utilização do sinal de \textit{carryIn} que é colocado em nível alto, em busca de verificar a diferença entre esta operação e a operação de soma sem o \textit{carry}. Além disso, temos o enumerado descrito na Unidade Lógica e Aritmética para verificarmos qual operação é realizada dentro deste componente, podemos ver que esta linha é alterada para \textbf{op\_addCarry}, e por fim temos o registrador AX, o qual está sendo manipulado, para verificarmos a alteração em seu valor. Podemos verificar que a instrução está funcionando corretamente, pois o valor do registrador AX é alterado para \textbf{1235h} após a execução da instrução e todos os estados são percorridos, como realmente deveriam ser em ambas unidades de controle.

\begin{landscape}
	\begin{figure}
		\includegraphics[scale=0.5]{imagensResultados/OperacaoAdc.png}
		\caption{Resultado Teste Operação ADC}
		\label{FigResultAdc}
	\end{figure}
\end{landscape}

\section{SBB Reg16,Imed16}
Esta instrução subtrai, com borrow, ao valor do registro um valor imediato de 16 bits, a instrução de teste em hexadecimal é definida como \textbf{81D8 1234} onde 81D8h é o opcode da instrução e 1234h é o valor imediato a ser subtraído com borrow no registro AX, por utilizar R/M igual a 000 como vimos anteriormente. Na figura \ref{FigResultSbb} podemos ver o resultado da execução do \textit{testbench}, com os sinais que mais nos interessam no funcionamento tanto da memória quanto do microprocessador para esta operação, as linhas de relógio e reset são responsáveis pelo funcionamento e passo a passo do microprocessador, tanto que enquanto a linha de reset não fica em nível alto, o microprocessador não responde. Temos os sinais dos estados da Unidade de Controle e da Unidade de Controle de Endereço, úteis para verificar se a linha de raciocínio, presente nos grafos descritos anteriormente, está correta e respeitando a ordem de mestre e escravo imposta. Temos o endereço e a saída da memória ROM, exteriorizadas de maneira a verificar se o microprocessador está colocando no barramento de endereço o valor correto e se a memória coloca no barramento de dados o valor correto do \textit{opcode}. Temos também a utilização do sinal de \textit{carryIn}, que neste caso é utilizado como borrow, é colocado em nível alto, em busca de verificar a diferença entre esta operação e a operação de subtração sem o \textit{borrow}. Além disso, temos o enumerado descrito na Unidade Lógica e Aritmética para verificarmos qual operação é realizada dentro deste componente, podemos ver que esta linha se mantem em  \textbf{op\_subCarry}, e por fim temos o registrador AX, o qual está sendo manipulado, para verificarmos a alteração em seu valor. Podemos verificar que a instrução está funcionando corretamente, pois o valor do registrador AX é alterado para \textbf{EDCBh} após a execução da instrução e todos os estados são percorridos, como realmente deveriam ser em ambas unidades de controle.

\begin{landscape}
	\begin{figure}
		\includegraphics[scale=0.5]{imagensResultados/OperacaoSbb.png}
		\caption{Resultado Teste Operação SBB}
		\label{FigResultSbb}
	\end{figure}
\end{landscape}

\section{AND Reg16,Imed16}
Esta instrução realiza a operação \"AND\"  bit a bit do valor do registro com um valor imediato de 16 bits, a instrução de teste em hexadecimal é definida como \textbf{81E0 1234} onde 81E0h é o opcode da instrução e 1234h é o valor imediato a ser realizado a operação \"AND\" com o registro AX, por utilizar R/M igual a 000 como vimos anteriormente. Na figura \ref{FigResultAnd} podemos ver o resultado da execução do \textit{testbench}, com os sinais que mais nos interessam no funcionamento tanto da memória quanto do microprocessador para esta operação, as linhas de relógio e reset são responsáveis pelo funcionamento e passo a passo do microprocessador, tanto que enquanto a linha de reset não fica em nível alto, o microprocessador não responde. Temos os sinais dos estados da Unidade de Controle e da Unidade de Controle de Endereço, úteis para verificar se a linha de raciocínio, presente nos grafos descritos anteriormente, está correta e respeitando a ordem de mestre e escravo imposta. Temos o endereço e a saída da memória ROM, exteriorizadas de maneira a verificar se o microprocessador está colocando no barramento de endereço o valor correto e se a memória coloca no barramento de dados o valor correto do \textit{opcode}. Além disso, temos o enumerado descrito na Unidade Lógica e Aritmética para verificarmos qual operação é realizada dentro deste componente, podemos ver que esta linha se mantem em  \textbf{op\_a\_and\_b}, e por fim temos o registrador AX, o qual está sendo manipulado, para verificarmos a alteração em seu valor. Podemos verificar que a instrução está funcionando corretamente, pois o valor do registrador AX é alterado para \textbf{0000h} após a execução da instrução e todos os estados são percorridos, como realmente deveriam ser em ambas unidades de controle.

\begin{landscape}
	\begin{figure}
		\includegraphics[scale=0.5]{imagensResultados/OperacaoAnd.png}
		\caption{Resultado Teste Operação AND}
		\label{FigResultAnd}
	\end{figure}
\end{landscape}

\section{SUB Reg16,Imed16}
Esta instrução subtrai ao valor do registro um valor imediato de 16 bits, a instrução de teste em hexadecimal é definida como \textbf{81E8 1234} onde 81E8h é o opcode da instrução e 1234h é o valor imediato a ser subtraído no registro AX, por utilizar R/M igual a 000 como vimos anteriormente. Na figura \ref{FigResultSub} podemos ver o resultado da execução do \textit{testbench}, com os sinais que mais nos interessam no funcionamento tanto da memória quanto do microprocessador para esta operação, as linhas de relógio e reset são responsáveis pelo funcionamento e passo a passo do microprocessador, tanto que enquanto a linha de reset não fica em nível alto, o microprocessador não responde. Temos os sinais dos estados da Unidade de Controle e da Unidade de Controle de Endereço, úteis para verificar se a linha de raciocínio, presente nos grafos descritos anteriormente, está correta e respeitando a ordem de mestre e escravo imposta. Temos o endereço e a saída da memória ROM, exteriorizadas de maneira a verificar se o microprocessador está colocando no barramento de endereço o valor correto e se a memória coloca no barramento de dados o valor correto do \textit{opcode}. Além disso, temos o enumerado descrito na Unidade Lógica e Aritmética para verificarmos qual operação é realizada dentro deste componente, podemos ver que esta linha se mantem em  \textbf{op\_sub}, e por fim temos o registrador AX, o qual está sendo manipulado, para verificarmos a alteração em seu valor. Podemos verificar que a instrução está funcionando corretamente, pois o valor do registrador AX é alterado para \textbf{EDCCh} após a execução da instrução e todos os estados são percorridos, como realmente deveriam ser em ambas unidades de controle.

\begin{landscape}
	\begin{figure}
		\includegraphics[scale=0.5]{imagensResultados/OperacaoSub.png}
		\caption{Resultado Teste Operação SUB}
		\label{FigResultSub}
	\end{figure}
\end{landscape}

\section{XOR Reg16,Imed16}
Esta instrução realiza a operação "XOR"  bit a bit do valor do registro com um valor imediato de 16 bits, a instrução de teste em hexadecimal é definida como \textbf{81E8 1234} onde 81E8h é o opcode da instrução e 1234h é o valor imediato a ser realizado a operação "XOR"  com o registro AX, por utilizar R/M igual a 000 como vimos anteriormente. Temos na figura \ref{FigResultXor} o resultado da simulação.

\begin{landscape}
	\begin{figure}
		\includegraphics[scale=0.5]{imagensResultados/OperacaoXor.png}
		\caption{Resultado Teste Operação XOR}
		\label{FigResultXor}
	\end{figure}
\end{landscape}

\section{CMP Reg16,Imed16}
Esta instrução realiza a comparação ao valor do registro um valor imediato de 16 bits, a instrução de teste em hexadecimal é definida como \textbf{81F8 1234} onde 81F8h é o opcode da instrução e 1234h é o valor imediato a ser comparado com o registro AX, por utilizar R/M igual a 000 como vimos anteriormente. Temos na figura \ref{FigResultComp} o resultado da simulação.

\begin{landscape}
	\begin{figure}
		\includegraphics[scale=0.5]{imagensResultados/OperacaoCmp.png}
		\caption{Resultado Teste Operação CMP}
		\label{FigResultComp}
	\end{figure}
\end{landscape}

\section{MOV Reg16,Imed16}
Esta instrução move um valor imediato de 16 bits para um determinador registrador, a instrução de teste em hexadecimal é definida como \textbf{00B8 1234} onde 00B8h é o opcode da instrução e 1234h é o valor imediato a ser movido para o registro AX, por utilizar R/M igual a 000 como vimos anteriormente. Temos na figura \ref{FigResultMov} o resultado da simulação.

\begin{landscape}
	\begin{figure}
		\includegraphics[scale=0.5]{imagensResultados/OperacaoMov.png}
		\caption{Resultado Teste Operação MOV}
		\label{FigResultMov}
	\end{figure}
\end{landscape}
